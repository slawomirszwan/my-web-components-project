Tak, Web Components obsÅ‚ugujÄ… coÅ› podobnego do children w React, ale w nieco inny sposÃ³b. GÅ‚Ã³wnym mechanizmem jest uÅ¼ycie slots (gniazd) w Shadow DOM.

Podstawowa konkoncepcja Slots
Slots pozwalajÄ… na wstawienie treÅ›ci z light DOM (zwykÅ‚ego HTML) do shadow DOM (komponentu).

PrzykÅ‚ad podstawowy
Definicja komponentu:

javascript


class MyComponent extends HTMLElement {
  constructor() {
    super();
    this.attachShadow({ mode: 'open' });
  }

  connectedCallback() {
    this.shadowRoot.innerHTML = `
      <div>
        <h2>NagÅ‚Ã³wek komponentu</h2>
        <slot></slot>
      </div>
    `;
  }
}

customElements.define('my-component', MyComponent);
UÅ¼ycie:

html


<my-component>
  <p>To jest treÅ›Ä‡, ktÃ³ra trafi do slotu.</p>
  <span>I to teÅ¼</span>
</my-component>
W tym przykÅ‚adzie, wszystko wewnÄ…trz znacznika <my-component> zostanie wstawione w miejsce <slot></slot>.

Nazwane sloty (Named Slots)
MoÅ¼esz teÅ¼ mieÄ‡ wiele slotÃ³w, kaÅ¼dy z nazwÄ….

Definicja komponentu:

javascript


class MyComponent extends HTMLElement {
  constructor() {
    super();
    this.attachShadow({ mode: 'open' });
  }

  connectedCallback() {
    this.shadowRoot.innerHTML = `
      <div>
        <header>
          <slot name="header"></slot>
        </header>
        <main>
          <slot name="content"></slot>
        </main>
        <footer>
          <slot name="footer"></slot>
        </footer>
      </div>
    `;
  }
}

customElements.define('my-component', MyComponent);
UÅ¼ycie:

html


<my-component>
  <h1 slot="header">TytuÅ‚</h1>
  <p slot="content">TreÅ›Ä‡ artykuÅ‚u...</p>
  <button slot="footer">Kliknij</button>
</my-component>
DostÄ™p do children/slotted content
Aby uzyskaÄ‡ dostÄ™p do elementÃ³w wslotowanych (odpowiednik children), moÅ¼esz uÅ¼yÄ‡:

Metoda 1: slot.assignedElements()
javascript


class MyComponent extends HTMLElement {
  constructor() {
    super();
    this.attachShadow({ mode: 'open' });
  }

  connectedCallback() {
    this.shadowRoot.innerHTML = `
      <div>
        <slot name="content"></slot>
      </div>
    `;

    // Poczekaj na renderowanie
    setTimeout(() => {
      const slot = this.shadowRoot.querySelector('slot[name="content"]');
      const assignedElements = slot.assignedElements();
      console.log(assignedElements); // Tablica elementÃ³w wslotowanych
    });
  }
}
Metoda 2: Zdarzenie slotchange
javascript


class MyComponent extends HTMLElement {
  constructor() {
    super();
    this.attachShadow({ mode: 'open' });
  }

  connectedCallback() {
    this.shadowRoot.innerHTML = `
      <div>
        <slot name="content"></slot>
      </div>
    `;

    const slot = this.shadowRoot.querySelector('slot[name="content"]');
    slot.addEventListener('slotchange', () => {
      const assignedElements = slot.assignedElements();
      console.log('Slot zmieniony:', assignedElements);
    });
  }
}
RÃ³Å¼nice w porÃ³wnaniu do React children
Slots sÄ… bardziej szablonowe - w React children to dowolna treÅ›Ä‡, w Web Components musisz okreÅ›liÄ‡ gdzie ma trafiÄ‡ jaka treÅ›Ä‡ (chyba Å¼e uÅ¼yjesz domyÅ›lnego slotu).

Stylowanie - elementy wslotowane sÄ… stylowane z light DOM, ale komponent moÅ¼e dostarczyÄ‡ niektÃ³re style (przy uÅ¼yciu CSS custom properties lub ::slotted).

Reakcja na zmiany - w React children sÄ… dynamiczne, w Web Components musisz obserwowaÄ‡ zmiany w slocie (zdarzenie slotchange).

PrzykÅ‚ad z dynamicznÄ… obsÅ‚ugÄ… children
javascript


class DynamicList extends HTMLElement {
  constructor() {
    super();
    this.attachShadow({ mode: 'open' });
  }

  connectedCallback() {
    this.shadowRoot.innerHTML = `
      <ul>
        <slot id="items-slot"></slot>
      </ul>
    `;

    const slot = this.shadowRoot.getElementById('items-slot');
    slot.addEventListener('slotchange', () => {
      const items = slot.assignedElements();
      items.forEach((item, index) => {
        // MoÅ¼esz dodaÄ‡ jakieÅ› zachowanie do kaÅ¼dego elementu
        item.style.setProperty('--index', index);
      });
    });
  }
}

customElements.define('dynamic-list', DynamicList);
UÅ¼ycie:

html


<dynamic-list>
  <li>Item 1</li>
  <li>Item 2</li>
  <li>Item 3</li>
</dynamic-list>
Podsumowanie
Web Components uÅ¼ywa slots do przekazywania treÅ›ci (odpowiednik children w React). MoÅ¼esz mieÄ‡:

Slot domyÅ›lny - dla treÅ›ci bez atrybutu slot
Nazwane sloty - dla precyzyjnego umieszczania treÅ›ci
DostÄ™p do tych elementÃ³w uzyskujesz przez:

slot.assignedElements() - zwraca elementy
slot.assignedNodes() - zwraca wÄ™zÅ‚y (w tym tekstowe)
Zdarzenie slotchange - gdy zmienia siÄ™ zawartoÅ›Ä‡ slotu
Jest to potÄ™Å¼ny mechanizm, ktÃ³ry pozwala na tworzenie komponentÃ³w z dowolnÄ… treÅ›ciÄ…, podobnie jak w React.

Tak, Web Components obsÅ‚ugujÄ… coÅ› podobnego do children z Reacta, ale w inny sposÃ³b. GÅ‚Ã³wnym mechanizmem sÄ… slots (gniazda), ktÃ³re peÅ‚niÄ… podobnÄ… rolÄ™.

Podstawowy mechanizm: Slots
1. DomyÅ›lny slot (podobny do children)
JavaScript

class MyComponent extends HTMLElement {
  constructor() {
    super()
    this.attachShadow({ mode: 'open' })
  }

  connectedCallback() {
    this.shadowRoot.innerHTML = `
      <div class="container">
        <h2>NagÅ‚Ã³wek komponentu</h2>
        <slot></slot> <!-- Tutaj trafiÄ… children -->
      </div>
    `
  }
}

customElements.define('my-component', MyComponent)
UÅ¼ycie:

HTML

<my-component>
  <p>To jest child 1</p>
  <span>To jest child 2</span>
  <div>To jest child 3</div>
</my-component>
2. Nazwane sloty (named slots)
JavaScript

class CardComponent extends HTMLElement {
  constructor() {
    super()
    this.attachShadow({ mode: 'open' })
  }

  connectedCallback() {
    this.shadowRoot.innerHTML = `
      <div class="card">
        <header class="card-header">
          <slot name="header">DomyÅ›lny nagÅ‚Ã³wek</slot>
        </header>
        <div class="card-content">
          <slot name="content"></slot>
        </div>
        <footer class="card-footer">
          <slot name="footer"></slot>
        </footer>
      </div>
    `
  }
}

customElements.define('card-component', CardComponent)
UÅ¼ycie:

HTML

<card-component>
  <h1 slot="header">MÃ³j tytuÅ‚</h1>
  <div slot="content">
    <p>TreÅ›Ä‡ karty</p>
    <button>Przycisk</button>
  </div>
  <div slot="footer">
    Stopka karty
  </div>
</card-component>
RÃ³Å¼nice w porÃ³wnaniu do React children
ğŸ”„ React children:
React

// React - bezpoÅ›redni dostÄ™p do children
function MyComponent({ children }) {
  return (
    <div>
      <h2>NagÅ‚Ã³wek</h2>
      {children} {/* Children renderowane bezpoÅ›rednio */}
    </div>
  )
}

// UÅ¼ycie
<MyComponent>
  <p>Child 1</p>
  <span>Child 2</span>
</MyComponent>
ğŸ”„ Web Components slots:
HTML

<!-- Web Components - przez sloty -->
<my-component>
  <p>Child 1</p>
  <span>Child 2</span>
</my-component>

<!-- WewnÄ…trz shadow DOM: -->
<div>
  <h2>NagÅ‚Ã³wek</h2>
  <slot></slot> <!-- Children pojawiÄ… siÄ™ tutaj -->
</div>
Zaawansowane techniki pracy z "children"
1. Dynamiczny dostÄ™p do slotted content
JavaScript

class DynamicComponent extends HTMLElement {
  constructor() {
    super()
    this.attachShadow({ mode: 'open' })
  }

  connectedCallback() {
    this.shadowRoot.innerHTML = `
      <div>
        <slot id="main-slot"></slot>
      </div>
    `

    // DostÄ™p do elementÃ³w w slocie
    const slot = this.shadowRoot.getElementById('main-slot')
    
    slot.addEventListener('slotchange', () => {
      const assignedElements = slot.assignedElements()
      console.log('Elementy w slocie:', assignedElements)
      
      // MoÅ¼esz manipulowaÄ‡ children
      assignedElements.forEach(element => {
        element.style.color = 'blue'
      })
    })
  }
}

customElements.define('dynamic-component', DynamicComponent)
2. Filtrowanie i transformacja children
JavaScript

class FilterComponent extends HTMLElement {
  constructor() {
    super()
    this.attachShadow({ mode: 'open' })
  }

  connectedCallback() {
    this.shadowRoot.innerHTML = `
      <div class="filtered-container">
        <slot></slot>
      </div>
    `

    const slot = this.shadowRoot.querySelector('slot')
    
    slot.addEventListener('slotchange', () => {
      const children = slot.assignedElements()
      
      // Filtruj tylko przyciski
      const buttons = children.filter(child => 
        child.tagName.toLowerCase() === 'button'
      )
      
      buttons.forEach(button => {
        button.classList.add('filtered-button')
      })
    })
  }
}
3. Kompozycja z wieloma slotami
JavaScript

class LayoutComponent extends HTMLElement {
  constructor() {
    super()
    this.attachShadow({ mode: 'open' })
  }

  connectedCallback() {
    this.shadowRoot.innerHTML = `
      <div class="layout">
        <aside class="sidebar">
          <slot name="sidebar"></slot>
        </aside>
        <main class="content">
          <slot name="content"></slot>
        </main>
        <div class="actions">
          <slot name="actions">
            <button>DomyÅ›lna akcja</button>
          </slot>
        </div>
      </div>
    `
  }
}

customElements.define('layout-component', LayoutComponent)
RÃ³Å¼nice i ograniczenia
âœ… PodobieÅ„stwa do React children:
MoÅ¼liwoÅ›Ä‡ przekazywania dowolnej treÅ›ci
Kompozycja komponentÃ³w
Reagowanie na zmiany zawartoÅ›ci
âŒ RÃ³Å¼nice/ograniczenia:
Brak bezpoÅ›redniego dostÄ™pu jak do props.children
Stylowanie - dzieci sÄ… stylowane z zewnÄ…trz, nie z shadow DOM
Event delegation - eventy muszÄ… "przebijaÄ‡ siÄ™" przez shadow boundary
Dynamiczne zmiany wymagajÄ… rÄ™cznej obsÅ‚ugi slotchange
RozwiÄ…zania zaawansowane
1. ObsÅ‚uga dynamicznych children
JavaScript

class DynamicChildrenComponent extends HTMLElement {
  constructor() {
    super()
    this.attachShadow({ mode: 'open' })
    this._slot = null
  }

  connectedCallback() {
    this.shadowRoot.innerHTML = `
      <div>
        <slot></slot>
        <div id="dynamic-children"></div>
      </div>
    `

    this._slot = this.shadowRoot.querySelector('slot')
    this._dynamicContainer = this.shadowRoot.getElementById('dynamic-children')
    
    this._setupSlotObserver()
  }

  _setupSlotObserver() {
    this._slot.addEventListener('slotchange', () => {
      this._processChildren()
    })
  }

  _processChildren() {
    const children = this._slot.assignedElements()
    
    // Przetwarzanie children
    children.forEach(child => {
      if (child.dataset.transform) {
        this._transformChild(child)
      }
    })
  }

  _transformChild(child) {
    const cloned = child.cloneNode(true)
    cloned.classList.add('transformed')
    this._dynamicContainer.appendChild(cloned)
  }
}
2. WÅ‚asna implementacja children-like API
JavaScript

class ReactLikeComponent extends HTMLElement {
  get children() {
    const slot = this.shadowRoot.querySelector('slot')
    return slot ? slot.assignedElements() : []
  }

  connectedCallback() {
    this.attachShadow({ mode: 'open' })
    this.shadowRoot.innerHTML = `
      <div>
        <slot></slot>
      </div>
    `

    // Symulacja React children API
    this._slot = this.shadowRoot.querySelector('slot')
    this._slot.addEventListener('slotchange', () => {
      this._children = this.children
      this.onChildrenChange && this.onChildrenChange(this._children)
    })
  }

  // Metoda podobna do React.Children.map
  mapChildren(callback) {
    return this.children.map(callback)
  }

  // Filtrowanie children
  filterChildren(predicate) {
    return this.children.filter(predicate)
  }
}

customElements.define('react-like-component', ReactLikeComponent)
Praktyczne uÅ¼ycie
HTML

<react-like-component>
  <div class="item" data-important="true">Item 1</div>
  <div class="item">Item 2</div>
  <div class="item" data-important="true">Item 3</div>
</react-like-component>

<script>
  const component = document.querySelector('react-like-component')
  component.onChildrenChange = (children) => {
    const importantItems = children.filter(child => 
      child.dataset.important === 'true'
    )
    console.log('WaÅ¾ne elementy:', importantItems)
  }
</script>
Podsumowanie
Web Components uÅ¼ywa slotÃ³w zamiast children, ale osiÄ…ga podobne cele:

âœ… Kompozycja komponentÃ³w - przez <slot>
âœ… Przekazywanie treÅ›ci - przez named slots
âœ… Reagowanie na zmiany - przez event slotchange
âœ… Manipulacja zawartoÅ›ciÄ… - przez assignedElements()
ChociaÅ¼ API jest inne niÅ¼ w React, jest rÃ³wnie potÄ™Å¼ne i po przyswojeniu staje siÄ™ bardzo intuicyjne w uÅ¼yciu.